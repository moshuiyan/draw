<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ—‹è½¬ğŸ’¯â˜è½¨è¿¹çƒ</title>
  </head>
  <body>
    <canvas id="3d"></canvas>

    <!-- é€šè¿‡ç›¸æœºçš„è¿åŠ¨æ¥å®ç°è§†å›¾å˜æ¢ï¼Œé‚£ä¸å°±æ˜¯è§†å›¾çŸ©é˜µ -->
  </body>
  <script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    uniform mat4 u_PvMatrix;
    uniform mat4 u_ModelMatrix;
    void main(){
      gl_Position = u_PvMatrix*u_ModelMatrix*a_Position;
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_Color;
    void main(){
      gl_FragColor=u_Color;
    }
  </script>

  <script type="module">
    import Poly from "../../util/Poly-1.js";
    import {
      Matrix4,
      Vector3,
      Vector2,
      Quaternion,
      Object3D,
      OrthographicCamera,
      PerspectiveCamera,
      Spherical,
    } from "../../../crystalocean-three.js-master/three.js/build/three.module.js";
    import { initShaders, parseColorStops } from "../../util/initShader.js";
    const canvas = document.getElementById("3d");
    const fs = document.getElementById("fragmentShader").textContent;
    const vs = document.getElementById("vertexShader").innerText;
    const { sin , cos}  = Math;
    const du  = Math.PI / 180
    canvas.width = self.innerWidth - 10;
    canvas.height = self.innerHeight - 50;
    const [viewH, viewW] = [canvas.height, canvas.width];
    const ratio = viewH / viewW;
    const gl = canvas.getContext("webgl");
    // å¯ç”¨æ·±åº¦æµ‹è¯•   å¼€å¯æ·±åº¦ç¼“å†²åŒº è®©å‰é¢çš„ç‰©ä½“æ­£å¸¸é®æŒ¡åé¢çš„ç‰©ä½“
    gl.enable(gl.DEPTH_TEST);

    initShaders(gl, vs, fs);
    gl.clearColor(0, 0, 0, 1);
    /* æ­£äº¤ç›¸æœº */
    const [near, far, left, right, top, bottom] = [
      1,
      8,
      -2 /ratio,
      2/ ratio,
      2 ,
      -2 ,
    ];
    const camera = new OrthographicCamera(left, right, top, bottom, near, far);

    const eye = new Vector3(1, 1, 2);
    const up = new Vector3(0, 1, 0);
    const target = new Vector3(0, 0, -3);

    camera.position.copy(eye);
    camera.lookAt(target);
    camera.updateMatrixWorld(); // ä¹‹å‰è¿™é‡Œæ²¡ä¼ å‚ å¯¼è‡´äº†æ—‹è½¬åæœ‰äº›éƒ¨åˆ†ä¼šè’™ä¸Šé»‘è‰²
    const pvMatrix = new Matrix4().multiplyMatrices(
      camera.projectionMatrix,
      camera.matrixWorldInverse
    );
    const triangle1 = crtTriangle(
      [1, 0, 0, 1],
      /* æˆ‘è¿™ä¸ªç‰ˆæœ¬çš„setPosition éœ€ä¼ å…¥å‘é‡ */
      new Matrix4().setPosition(new Vector3(-1, 0, -7)).elements
    );
    const triangle2 = crtTriangle(
      [1, 0, 0, 1],
      new Matrix4().setPosition(new Vector3(1, 0, -7)).elements
    );
    const triangle3 = crtTriangle(
      [1, 1, 0, 1],
      new Matrix4().setPosition(new Vector3(-1, 0, -2)).elements
    );
    const triangle4 = crtTriangle(
      [1, 1, 0, 1],
      new Matrix4().setPosition(new Vector3(1, 0, -2)).elements
    );
    const circle1 = crtCircle([1,0,1,1], new Matrix4().setPosition(new Vector3(0,0,-5)),[0,0,0], [1,1,1]);

    render();
    // #region
    function render() {
      gl.clear(gl.COLOR_BUFFER_BIT);

      triangle1.init();
      triangle1.draw();

      triangle2.init();
      triangle2.draw();

      triangle3.init();
      triangle3.draw();

      triangle4.init();
      triangle4.draw();
      circle1.init();
      circle1.draw();
    }
    // ç¬¬ä¸€ä¸ªä¸‰è§’å½¢ é€†æ—¶é’ˆï¼Œåé¢å…¨éƒ¨ç”¨fanä¸‰è§’æ‰‡ï¼Œå°±èƒ½ç”»å‡ºä»¥èµ·ç‚¹ä¸ºåœ†å¿ƒçš„åœ†
    function crtTriangle(color, modelMatrix) {
      console.log(modelMatrix);
      return new Poly({
        gl,
        source: [ 0, 0.3, 0,  0, -0.3, 0,  0.3, -0.3, 0,
                    0.3,0.3, 0 ,
                    0.3,0.3, -0.6 ,
                    0.0,0.3, -0.6 ,
                    0.0,0.3, -0.6 ,// åœ†çš„åŠå¾„0.6é€†æ—¶é’ˆ ä»0 ç‚¹å¼€å§‹ç”»
                    0,sin(10* du), cos(10*du),
                    0,sin(20* du), cos(20*du),
                    0,sin(30* du), cos(30*du),
                    0,sin(40* du), cos(40*du),
                    0,sin(50* du), cos(50*du),
                    0,sin(60* du), cos(60*du),
                    0,sin(70* du), cos(70*du),
                    0,sin(80* du), cos(80*du),
                    0,sin(90* du), cos(90*du), 
                    sin(10* du), cos(10*du),0,
                    sin(20* du), cos(20*du),0,
                    sin(30* du), cos(30*du),0,
                    sin(40* du), cos(40*du),0,
                    sin(50* du), cos(50*du),0,
                    sin(60* du), cos(60*du),0,
                    sin(70* du), cos(70*du),0,
                    sin(80* du), cos(80*du),0,
                    sin(90* du), cos(90*du),0,
                 ],
                  /* stripæ˜¯å¸¦  */
        types: ["TRIANGLE_FAN"],
        attributes: {
          a_Position: {
            size: 3,
            index: 0,
          },
          
        },
        uniforms: {
          u_Color: {
            type: "uniform4fv",
            value: color,
          },
          u_PvMatrix: {
            type: "uniformMatrix4fv",
            value: pvMatrix.elements,
          },
          u_ModelMatrix: {
            type: "uniformMatrix4fv",
            value: modelMatrix,
          },
        },
      });
    }
/*                                            åœ†å¿ƒ  èµ·ç¬”ç‚¹  è§’åº¦      */
    function crtCircle( color, modelMatrix, center, start,angle){
      const [x1,y1,z1] = center ;
      const [x2,y2,z2] = start ;
      let n = 37, points=[],r = Math.sqrt( (x2-x1)*(x2-x1)+ (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2)  )  ;
      while(n--){
        points.push(x1 ,y1+ r* sin(n*10* du),z1 + r * cos(n*10*du))
      }
      return new Poly({
        gl,
        source: points,
                  /* stripæ˜¯å¸¦ fanæ˜¯æ‰‡ */
        types: ["TRIANGLE_FAN"],
        attributes: {
          a_Position: {
            size: 3,
            index: 0,
          },
          
        },
        uniforms: {
          u_Color: {
            type: "uniform4fv",
            value: color,
          },
          u_PvMatrix: {
            type: "uniformMatrix4fv",
            value: pvMatrix.elements,
          },
          u_ModelMatrix: {
            type: "uniformMatrix4fv",
            value: modelMatrix.elements,
          },
        },
      });
    }

    /* é¼ æ ‡äº‹ä»¶é›†åˆ  event.button  0 1 2 
    2 å³é”® pan  ä½ç§»
    0 å·¦é”® rotate æ—‹è½¬

    æ»šè½®æ¯æ¬¡æ»šåŠ¨æ—¶scaleçš„å¢é‡çš„ç³»æ•° ä¹Ÿå°±æ˜¯åŠ é€Ÿåº¦

    */
    const pi2 = Math.PI * 2;
    const mouseButton = new Map([
      [2, "pan"],
      [0, "rotate"],
    ]);
    const spinAxis = new Set(["x", "y"]);
    const zoomScale = 0.95;
    /* æ—‹è½¬è½¨é“ è§†çº¿ä»ç›¸æœºä¸­å¿ƒæŒ‡å‘ç›®æ ‡   çƒåæ ‡ï¼ˆp, phi(Ï†), thetaï¼ˆÎ¸ï¼‰ï¼‰ ä¸‹é¢å°±æ˜¯ç›¸æœºè§†ç‚¹ç›¸å¯¹äºç›®æ ‡çš„çƒåæ ‡
     * æè§’æ˜¯ä»yè½´æ­£åŠè½´å¼€å§‹çš„ï¼Œ ä¸€èˆ¬yè½´æ­£åŠè½´ç«–ç›´å‘ä¸Š[0, 180]  æ–¹ä½è§’æ˜¯ä»zè½´æ­£åŠè½´å¼€å§‹çš„
     * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
     * The azimuthal angle (theta) is measured from the positive z-axis.
     */
    const spherical = new Spherical().setFromVector3(
      camera.position.clone().sub(target)
    );
    /* çŠ¶æ€ panè¡¨ç¤ºä½ç§» */
    let state = "none";
    /* æ‹–æ›³èµ·å§‹å’Œç»“æŸä½  å•ä½px*/
    const dragStart = new Vector2();
    const dragEnd = new Vector2();
    /* é¼ æ ‡æ¯æ¬¡ç§»åŠ¨é‡å•ä½webglåæ ‡é‡ */
    const panoffset = new Vector3();
    /* ç¡®å®šç«–ç›´æ–¹å‘ä¸Šçš„æ‹–æ›³ æ˜¯å¯¹åº”ç›¸æœºæœ¬åœ°åæ ‡ç³»çš„ yè½´è¿˜æ˜¯zè½´  true y  , false z */
    const screenSpacePanning = true;
    // å››å…ƒæ•°
    const quaternion = new Quaternion();
    // é˜»æ­¢é»˜è®¤å³é”®èœå•äº‹ä»¶
    canvas.oncontextmenu = (e) => {
      e.preventDefault();
    };
    // æŒ‡é’ˆ - pointer  pointerdown æŒ‡é’ˆæ¿€æ´»æ—¶è§¦å‘ï¼ŒpointupæŒ‡é’ˆä¸å†æ´»è·ƒ pointeræŒ‡é’ˆåæ ‡æ”¹å˜
    /*æŸä¸ªå‘ˆç°å½¢å¼å¹¶ä¸ç¡®å®šçš„ç¡¬ä»¶ï¼Œè¯¥ç¡¬ä»¶å¯ä»¥æŒ‡å‘ä¸€ä¸ªï¼ˆæˆ–ä¸€ç»„ï¼‰å±å¹•ä¸Šç‰¹å®šåæ ‡ã€‚å…¸å‹çš„æŒ‡é’ˆè¾“å…¥è®¾å¤‡æœ‰é¼ æ ‡ã€è§¦æ§ç¬”ã€æ‰‹æŒ‡è§¦æ§ç‚¹ç­‰ã€‚  */
    canvas.addEventListener("pointerdown", ({ clientX, clientY, button }) => {
      dragStart.set(clientX, clientY);
      state = mouseButton.get(button); // ä¿®æ”¹çŠ¶æ€
    });
    canvas.addEventListener("pointermove", ({ clientX, clientY, button }) => {
      dragEnd.set(clientX, clientY);

      /* æ ¹æ®ä¸åŒçŠ¶æ€ */
      switch (state) {
        case "pan":
          /*sub() ä»è¯¥å‘é‡å‡å»å‚æ•°å‘é‡ã€‚  */
          pan(dragEnd.clone().sub(dragStart));
          break;
        case "rotate":
          rotate(dragEnd.clone().sub(dragStart));
          break;
      }
      // æ›´æ–°æ‹–æ›³èµ·å§‹ä½
      dragStart.copy(dragEnd);
    });

    canvas.addEventListener("pointerup", (e) => {
      state = "none"; // æ¸…é™¤çŠ¶æ€
    });

    canvas.addEventListener("wheel", ({ deltaY }) => {
      if (deltaY < 0) {
        dolly(1 / zoomScale);
      } else if (deltaY > 0) {
        dolly(zoomScale);
      }
      update();
    });

    /* è¿™delta ä¸å°±æ˜¯â–³ å— ä½ç§» */
    function pan(delta) {
      // ç›¸æœºè¿‘è£å‰ªé¢çš„å°ºå¯¸
      const cameraW = camera.right - camera.left;
      const cameraH = camera.top - camera.bottom;
      // æŒ‡é’ˆä½ç§»é‡ æ¢ç®—ä¸ºç”»å¸ƒ å•ä½
      const ratioX = delta.x / canvas.clientWidth;
      const ratioY = delta.y / canvas.clientHeight;
      // ç”»å¸ƒ åˆ° ç›¸æœºä¸–ç•Œçš„è¿‘è£å‰ªé¢
      const distanceLeft = ratioX * cameraW;
      const distanceTop = ratioY * cameraH;
      // ç›¸æœºæœ¬åœ°åæ ‡xè½´   å–çŸ©é˜µçš„ç¬¬å‡ åˆ—   matrixå±æ€§ å±€éƒ¨å˜æ¢çŸ©é˜µ
      const mx = new Vector3().setFromMatrixColumn(camera.matrix, 0);
      const vx = mx.clone().multiplyScalar(-distanceLeft);
      const vy = new Vector3();
      if (screenSpacePanning) {
        vy.setFromMatrixColumn(camera.matrix, 1);
      } else {
        /* å‰ä¹˜ */
        vy.crossVectors(camera.up, mx);
      }
      vy.multiplyScalar(distanceTop);
      /* add å‘é‡åŠ æ³• */
      panoffset.copy(vx.add(vy));

      update();
    }
    /* ç¼©æ”¾ è¿™é‡Œç›´æ¥ç¼©æ”¾ç›¸æœºçš„è¿‘è£å‰ªé¢ï¼Œ ç›¸æœºè£å‰ªé¢å’Œå¯è§†åŒºåŸŸçš„æ¯”å€¼è¶Šå°ï¼Œ æ˜¾ç¤ºçš„å›¾å½¢å°±è¶Šå¤§ï¼Œçœ‹åˆ°èŒƒå›´å°±è¶Šå° */
    function dolly(delta) {
      camera.zoom *= delta;
      camera.updateProjectionMatrix(); // æ›´æ–°è§†å›¾çŸ©é˜µ
    }
    /* æ—‹è½¬ ç›¸æœºçš„æ—‹è½¬å°±æ˜¯è®©ç›¸æœºç»•æŸä¸€ç‚¹æ—‹è½¬ï¼Œ è½¨è¿¹é›†åˆæ˜¯ä¸€ä¸ªçƒã€‚
æ‰€ä»¥è¦å®šä½ç›®æ ‡ thetaæ˜¯æ–¹ä½è§’ä»zè½´å¼€å§‹

è¿™ä¸ªæ—‹è½¬æœ‰ä¸€äº›é—®é¢˜ ï¼Œç­‰ä¼šæ¥è¯•ç€æè¿°ä¸€ä¸‹ï¼Œ å¥½åƒæ˜¯å› ä¸ºæ²¡æœ‰å¼€å¯æ·±åº¦ï¼Œé®æŒ¡å…³ç³»ä¸æ­£å¸¸ï¼›
æ­£çœŸçš„é—®é¢˜æ˜¯ æˆ‘ç»•xæ—‹è½¬180åº¦çš„æ—¶å€™ï¼Œ æ•´ä¸ªåæ ‡ç³»ä¼¼ä¹ç›´æ¥zè½´å–åäº†
ä¸‡å‘é”ï¼Ÿ æ˜¯ä»€ä¹ˆ
*/

    /* ç°åœ¨æ˜¯è½¨è¿¹çƒ ä¹Ÿå°±æ˜¯å››å…ƒæ•° ç»•ä»»æ„è½´æ—‹è½¬ï¼Œ åº”è¯¥æ˜¯æ²¡æœ‰ä¹‹å‰æè§’å¯¼è‡´çš„é—®é¢˜ */
    function rotate({ x, y }) {
      // ç›¸æœºè¿‘è£å‰ªé¢çš„å°ºå¯¸
      const cameraW = camera.right - camera.left;
      const cameraH = camera.top - camera.bottom;
      const { clientHeight, clientWidth } = canvas;
      const { right, left, top, bottom, matrix, position } = camera;
      /* é¼ æ ‡ä½ç§»åœ¨ç”»å¸ƒä¸­çš„å æ¯”  */
      const ratioX = x / clientWidth;
      const ratioY = -y / clientHeight; // yå¦‚æœä¸å–å ä¼šåç€
      /* åŸºäºé«˜åº¦çš„xçš„æ¯”å€¼ ç”¨äºè®¡ç®—æ—‹è½¬é‡ */
      const ratioBaseHeight = x / clientHeight;
      // ä½ç§»é‡
      const ratioLen = new Vector2(ratioBaseHeight, ratioY).length();
      // æ—‹è½¬é‡
      const angle = ratioLen * pi2;
      // ç›¸æœºä¸–ç•Œçš„ä½ç§»é‡ï¼›
      const distanceLeft = ratioX * cameraW;
      const distanceUp = ratioY * cameraH;
      // ç›¸æœºæœ¬åœ°åæ ‡çš„xyè½´
      const mx = new Vector3().setFromMatrixColumn(camera.matrix, 0);
      const my = new Vector3().setFromMatrixColumn(camera.matrix, 1);
      // å°†é¼ æ ‡åœ¨ç›¸æœºä¸–ç•Œçš„x y è½´å‘çš„ä½ç§»é‡è½¬æ¢ä¸ºä¸–ç•Œåæ ‡ä½ï¼›
      const vx = mx.clone().multiplyScalar(distanceLeft);
      const vy = my.clone().multiplyScalar(distanceUp);
      // é¼ æ ‡åœ¨ s j z ä¸­çš„ä½ç§»æ–¹å‘-xè½´
      const moveDir = vx.clone().add(vy).normalize();
      // ç›®æ ‡ç‚¹åˆ°è§†ç‚¹çš„å•ä½å‘é‡-zè½´
      const eyeDir = camera.position.clone().sub(target).normalize();
      // åŸºäºä½ç§»æ–¹å‘å’Œè§†çº¿è·å–æ—‹è½¬è½´ä¸Šæ–¹å‘ yè½´
      const axis = moveDir.clone().cross(eyeDir);
      console.log( moveDir,'xè½´' )
      console.log( eyeDir,'yè½´' )
      console.log( axis,'yè½´' )

      // åŸºäºæ—‹è½¬è½´å’Œæ—‹è½¬é‡å»ºç«‹å››å…ƒæ•°
      quaternion.setFromAxisAngle(axis, angle);
      update();
      //   console.log(pvMatrix.elements);
    }

    function update() {
      /* å¹³ç§»ç›¸æœºè¦æŠŠç›®æ ‡ç‚¹ä½ä¸€èµ·ç§»åŠ¨ï¼Œ ä¿æŒè§†çº¿ï¼Œ */
      target.add(panoffset);
      camera.position.add(panoffset);
      /*æ—‹è½¬ç›¸æœº */
      /*   const rotateOffset = new Vector3().setFromSpherical(spherical) ;
  camera.position.copy( target.clone().add(rotateOffset))  */
      // åŸºäºå››å…ƒæ•°
      // æ—‹è½¬è§†çº¿
      const rotateOffset = camera.position
        .clone()
        .sub(target)
        .applyQuaternion(quaternion);
      // åŸºäºæ–°è§†çº¿è®¾ç½®ç›¸æœºä½ç½®
      camera.position.copy(target.clone().add(rotateOffset));
      //è®¾ç½®ä¸Šæ–¹å‘
      camera.up.applyQuaternion(quaternion);
      // æ›´æ–°è§†å›¾æŠ•å½±çŸ©é˜µ
      camera.lookAt(target);
      camera.updateMatrixWorld(true);
      pvMatrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
      );
      /* é‡ç½®æ—‹è½¬é‡å’Œä½ç§»é‡ */
      quaternion.setFromRotationMatrix(new Matrix4());
      panoffset.set(0, 0, 0);
      render();
    }
  </script>
</html>
