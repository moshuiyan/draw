<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›¸æœºè½¨é“â€”â€”â€”â€”æ—‹è½¬ğŸ’¯</title>
</head>
<body>
    <canvas id=3d></canvas>
    

    <!-- é€šè¿‡ç›¸æœºçš„è¿åŠ¨æ¥å®ç°è§†å›¾å˜æ¢ï¼Œé‚£ä¸å°±æ˜¯è§†å›¾çŸ©é˜µ -->
</body>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    uniform mat4 u_PvMatrix;
    uniform mat4 u_ModelMatrix;
    void main(){
      gl_Position = u_PvMatrix*u_ModelMatrix*a_Position;
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_Color;
    void main(){
      gl_FragColor=u_Color;
    }
</script>

<script type="module">
    import Poly from '../../util/Poly-1.js' ;
    import { Matrix4, Vector3, Vector2, Quaternion, Object3D, OrthographicCamera , PerspectiveCamera, Spherical} from '../../../crystalocean-three.js-master/three.js/build/three.module.js';
    import { initShaders , parseColorStops} from '../../util/initShader.js';
    const canvas = document.getElementById('3d') ;
    const fs  = document.getElementById('fragmentShader').textContent ;
    const vs  = document.getElementById('vertexShader').innerText ;

    canvas.width = self.innerWidth -10;
    canvas.height = self.innerHeight -50;
    const [viewH, viewW] = [canvas.height, canvas.width] ;
    const ratio = viewH/viewW
    const gl = canvas.getContext('webgl') ;
        // å¯ç”¨æ·±åº¦æµ‹è¯•   å¼€å¯æ·±åº¦ç¼“å†²åŒº è®©å‰é¢çš„ç‰©ä½“æ­£å¸¸é®æŒ¡åé¢çš„ç‰©ä½“
        gl.enable(gl.DEPTH_TEST);
    initShaders(gl,vs, fs) ;
    gl.clearColor(0, 0, 0, 1)
/* æ­£äº¤ç›¸æœº */
    const [near, far, left, right, top, bottom] = [ 1, 8 ,  -2 ,2 ,2*ratio, -2*ratio ];
    const camera = new OrthographicCamera(left, right, top, bottom, near, far);
    
    const eye = new Vector3(1,1,2);
    const up = new Vector3(0,1,0);
    const target = new Vector3(0,0, -3);

    camera.position.copy(eye);
    camera.lookAt(target) ;
    camera.updateMatrixWorld()
    const pvMatrix= new Matrix4().multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse)
    const triangle1 = crtTriangle(
    [1, 0, 0, 1],
    /* æˆ‘è¿™ä¸ªç‰ˆæœ¬çš„setPosition éœ€ä¼ å…¥å‘é‡ */
    new Matrix4().setPosition(new Vector3(-0.5, 0,-3)).elements
)
const triangle2 = crtTriangle(
    [1, 0, 0, 1],
    new Matrix4().setPosition(new Vector3(0.5, 0, -3)).elements
)
const triangle3 = crtTriangle(
    [1, 1, 0, 1],
    new Matrix4().setPosition(new Vector3(-0.5, 0, -2)).elements
)
const triangle4 = crtTriangle(
    [1, 1, 0, 1],
    new Matrix4().setPosition(new Vector3(0.5, 0, -2)).elements
)

render()
// #region
function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);

    triangle1.init()
    triangle1.draw()

    triangle2.init()
    triangle2.draw()

    triangle3.init()
    triangle3.draw()

    triangle4.init()
    triangle4.draw()

}
function crtTriangle(color, modelMatrix){
  console.log(modelMatrix)
        return new Poly({
            gl,
        source: [
          0, 0.3, 0,
          -0.3, -0.3, 0,
          0.3, -0.3, 0, 
        ],
        types: ['TRIANGLES',],
        attributes: {
          a_Position: {
            size: 3,
            index: 0
          },
        },
        uniforms: {
          u_Color: {
            type: 'uniform4fv',
            value: color
          },
          u_PvMatrix: {
            type: 'uniformMatrix4fv',
            value: pvMatrix.elements
          },
          u_ModelMatrix: { 
            type: 'uniformMatrix4fv',
            value: modelMatrix
          },
        }
        })
    }

    /* é¼ æ ‡äº‹ä»¶é›†åˆ  event.button  0 1 2 
    2 å³é”® pan  ä½ç§»
    0 å·¦é”® rotate æ—‹è½¬

    æ»šè½®æ¯æ¬¡æ»šåŠ¨æ—¶scaleçš„å¢é‡çš„ç³»æ•° ä¹Ÿå°±æ˜¯åŠ é€Ÿåº¦

    */
    const pi2 = Math.PI * 2 ;
    const mouseButton = new Map([[2,'pan'], [0, 'rotate']]);
    const spinAxis = new Set([ 'x','y'])
    const zoomScale = 0.95 ;
/* æ—‹è½¬è½¨é“ è§†çº¿ä»ç›¸æœºä¸­å¿ƒæŒ‡å‘ç›®æ ‡   çƒåæ ‡ï¼ˆp, phi(Ï†), thetaï¼ˆÎ¸ï¼‰ï¼‰ ä¸‹é¢å°±æ˜¯ç›¸æœºè§†ç‚¹ç›¸å¯¹äºç›®æ ‡çš„çƒåæ ‡
 * æè§’æ˜¯ä»yè½´æ­£åŠè½´å¼€å§‹çš„ï¼Œ ä¸€èˆ¬yè½´æ­£åŠè½´ç«–ç›´å‘ä¸Š[0, 180]  æ–¹ä½è§’æ˜¯ä»zè½´æ­£åŠè½´å¼€å§‹çš„
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */
    const spherical = new Spherical().setFromVector3(camera.position.clone().sub(target))
/* çŠ¶æ€ panè¡¨ç¤ºä½ç§» */
let state = 'none' ;
/* æ‹–æ›³èµ·å§‹å’Œç»“æŸä½  å•ä½px*/
const dragStart = new Vector2();
const dragEnd = new Vector2();
/* é¼ æ ‡æ¯æ¬¡ç§»åŠ¨é‡å•ä½webglåæ ‡é‡ */
const panoffset = new Vector3();
/* ç¡®å®šç«–ç›´æ–¹å‘ä¸Šçš„æ‹–æ›³ æ˜¯å¯¹åº”ç›¸æœºæœ¬åœ°åæ ‡ç³»çš„ yè½´è¿˜æ˜¯zè½´  true y  , false z */
const screenSpacePanning = true ;
// é˜»æ­¢é»˜è®¤å³é”®èœå•äº‹ä»¶
canvas.oncontextmenu = (e)=> {
e.preventDefault();
}
// æŒ‡é’ˆ - pointer  pointerdown æŒ‡é’ˆæ¿€æ´»æ—¶è§¦å‘ï¼ŒpointupæŒ‡é’ˆä¸å†æ´»è·ƒ pointeræŒ‡é’ˆåæ ‡æ”¹å˜ 
/*æŸä¸ªå‘ˆç°å½¢å¼å¹¶ä¸ç¡®å®šçš„ç¡¬ä»¶ï¼Œè¯¥ç¡¬ä»¶å¯ä»¥æŒ‡å‘ä¸€ä¸ªï¼ˆæˆ–ä¸€ç»„ï¼‰å±å¹•ä¸Šç‰¹å®šåæ ‡ã€‚å…¸å‹çš„æŒ‡é’ˆè¾“å…¥è®¾å¤‡æœ‰é¼ æ ‡ã€è§¦æ§ç¬”ã€æ‰‹æŒ‡è§¦æ§ç‚¹ç­‰ã€‚  */
canvas.addEventListener('pointerdown', ({clientX, clientY, button})=> {
  dragStart.set(clientX, clientY)  
  state = mouseButton.get(button ) // ä¿®æ”¹çŠ¶æ€
})
canvas.addEventListener('pointermove', ({clientX, clientY, button})=> {
    dragEnd.set(clientX, clientY);

    /* æ ¹æ®ä¸åŒçŠ¶æ€ */
    switch(state){
        case 'pan':
         /*sub() ä»è¯¥å‘é‡å‡å»å‚æ•°å‘é‡ã€‚  */
        pan(dragEnd.clone().sub(dragStart))
        break ;
          case 'rotate':
          rotate(dragEnd.clone().sub(dragStart))  
          break
    }
    // æ›´æ–°æ‹–æ›³èµ·å§‹ä½
    dragStart.copy(dragEnd);
})

canvas.addEventListener('pointerup', (e)=> {
    state = 'none' ; // æ¸…é™¤çŠ¶æ€
})

canvas.addEventListener('wheel', ({deltaY})=> {
  if(deltaY< 0){
    dolly(1/zoomScale)
  }else if (deltaY > 0) {
    dolly(zoomScale)
  }
  update()
})


/* è¿™delta ä¸å°±æ˜¯â–³ å— ä½ç§» */
function pan({delta}){
    // ç›¸æœºè¿‘è£å‰ªé¢çš„å°ºå¯¸
    const cameraW  = camera.right - camera.left ; 
    const cameraH  = camera.top - camera.bottom  ;
    // æŒ‡é’ˆä½ç§»é‡ æ¢ç®—ä¸ºç”»å¸ƒ å•ä½
    const ratioX = delta.x / canvas.clientWidth ; 
    const ratioY = delta.y / canvas.clientHeight ;
    // ç”»å¸ƒ åˆ° ç›¸æœºä¸–ç•Œçš„è¿‘è£å‰ªé¢ 
    const distanceLeft  = ratioX * cameraW
    const distanceTop  = ratioY * cameraH
    // ç›¸æœºæœ¬åœ°åæ ‡xè½´   å–çŸ©é˜µçš„ç¬¬å‡ åˆ—   matrixå±æ€§ å±€éƒ¨å˜æ¢çŸ©é˜µ
    const mx = new Vector3().setFromMatrixColumn(camera.matrix, 0);
    const vx = mx.clone().multiplyScalar(-distanceLeft)
    const vy = new Vector3();
    if(screenSpacePanning){
      vy.setFromMatrixColumn(camera.matrix, 1);

    }else {
      /* å‰ä¹˜ */
      vy.crossVectors(camera.up,mx);
    }
    vy.multiplyScalar(distanceTop);
    /* add å‘é‡åŠ æ³• */
    panoffset.copy(vx.add(vy));

    update()
}
/* ç¼©æ”¾ è¿™é‡Œç›´æ¥ç¼©æ”¾ç›¸æœºçš„è¿‘è£å‰ªé¢ï¼Œ ç›¸æœºè£å‰ªé¢å’Œå¯è§†åŒºåŸŸçš„æ¯”å€¼è¶Šå°ï¼Œ æ˜¾ç¤ºçš„å›¾å½¢å°±è¶Šå¤§ï¼Œçœ‹åˆ°èŒƒå›´å°±è¶Šå° */
function dolly(delta){
  camera.zoom*=delta;
  camera.updateProjectionMatrix(); // æ›´æ–°è§†å›¾çŸ©é˜µ
}
/* æ—‹è½¬ ç›¸æœºçš„æ—‹è½¬å°±æ˜¯è®©ç›¸æœºç»•æŸä¸€ç‚¹æ—‹è½¬ï¼Œ è½¨è¿¹é›†åˆæ˜¯ä¸€ä¸ªçƒã€‚
æ‰€ä»¥è¦å®šä½ç›®æ ‡ thetaæ˜¯æ–¹ä½è§’ä»zè½´å¼€å§‹

è¿™ä¸ªæ—‹è½¬æœ‰ä¸€äº›é—®é¢˜ ï¼Œç­‰ä¼šæ¥è¯•ç€æè¿°ä¸€ä¸‹ï¼Œ å¥½åƒæ˜¯å› ä¸ºæ²¡æœ‰å¼€å¯æ·±åº¦ï¼Œé®æŒ¡å…³ç³»ä¸æ­£å¸¸ï¼›
æ­£çœŸçš„é—®é¢˜æ˜¯ æˆ‘ç»•xæ—‹è½¬180åº¦çš„æ—¶å€™ï¼Œ æ•´ä¸ªåæ ‡ç³»ä¼¼ä¹ç›´æ¥zè½´å–åäº†
ä¸‡å‘é”ï¼Ÿ æ˜¯ä»€ä¹ˆ
*/
function rotate({x, y}){
const { clientHeight} = canvas ;
/* é™åˆ¶åªèƒ½ç»•æŸä¸ªè½´æ—‹è½¬ */
spinAxis.has('x')
let phi ;
spinAxis.has('x') && (spherical.theta -= pi2 * x /clientHeight) // è¿™æ„æ€å°±æ˜¯é¼ æ ‡åœ¨xæ–¹å‘ä¸Šä½ç§»ä¸ºä¸€ä¸ªç”»å¸ƒçš„é«˜æ—¶ ä¹Ÿå°±ç»•Yè½´è½¬äº†360
spinAxis.has('y') && (phi = spherical.phi -pi2 * y /clientHeight)  ;
/* é™åˆ¶phiè§’çš„èŒƒå›´  è™½ç„¶èŒƒå›´æ˜¯[0 ,180]ä½†å®é™…ä¸Šåº”æ˜¯(0, 180) æè§’å¦‚æœä¸º0 180é‚£å°±æ˜¯è§†çº¿å’Œå‘é‡ï¼ˆ0,1,0ï¼‰é‡åˆï¼Œé‚£ä¹ˆæ–¹ä½è§’å°†å¤±å»æ„ä¹‰*/
spherical.phi = Math.min(pi2 / 2 *0.99999, Math.max(1/100000, phi))
update()
console.log(pvMatrix.elements)
}

function update(){
  /* å¹³ç§»ç›¸æœºè¦æŠŠç›®æ ‡ç‚¹ä½ä¸€èµ·ç§»åŠ¨ï¼Œ ä¿æŒè§†çº¿ï¼Œ */
  target.add(panoffset);
  camera.position.add(panoffset);
/*æ—‹è½¬ç›¸æœº */
  const rotateOffset = new Vector3().setFromSpherical(spherical) ;
  camera.position.copy( target.clone().add(rotateOffset)) 

  camera.lookAt(target);
  camera.updateMatrixWorld(true);
  pvMatrix.multiplyMatrices(
    camera.projectionMatrix,
    camera.matrixWorldInverse
  )
  /* é‡ç½®æ—‹è½¬é‡å’Œä½ç§»é‡ */
  spherical.setFromVector3(
      camera.position.clone().sub(target) 
  )
  panoffset.set(0,0,0)
  render() ;
}


</script>
</html>